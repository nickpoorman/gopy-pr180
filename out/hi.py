"""
package hi exposes a few Go functions to be wrapped and used from Python.

"""
# python wrapper for package github.com/go-python/gopy/_examples/hi within overall package hi
# This is what you import to use the package.
# File is generated by gopy. Do not edit.
# gopy build -vm=python3 -output=/out github.com/go-python/gopy/_examples/hi

# the following is required to enable dlopen to open the _go.so file
import os,sys,inspect,collections
cwd = os.getcwd()
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
os.chdir(currentdir)
import _hi
os.chdir(cwd)

# to use this code in your end-user python file, import it as follows:
# from hi import hi
# and then refer to everything using hi. prefix
# packages imported by this package listed below:

import go



# ---- Types ---

# Python type for slice [2]int
class Array_2_int(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
	def __str__(self):
		s = 'hi.Array_2_int len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'hi.Array_2_int([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _hi.Array_2_int_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return _hi.Array_2_int_elem(self.handle, key)
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_hi.Array_2_int_set(self.handle, idx, value)
			return
		raise IndexError('slice index out of range')
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _hi.Array_2_int_elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration


#---- Constants from Go: Python can only ask that you please don't change these! ---
Universe = 42
Version = "0.1"


# ---- Global Variables: can only use functions to access ---
def Anon():
	"""
	Anon Gets Go Variable: hi.Anon
	
	"""
	return Person(handle=_hi.hi_Anon())

def Set_Anon(value):
	"""
	Set_Anon Sets Go Variable: hi.Anon
	
	"""
	if isinstance(value, go.GoClass):
		_hi.hi_Set_Anon(value.handle)
	else:
		_hi.hi_Set_Anon(value)

def Debug():
	"""
	Debug Gets Go Variable: hi.Debug
	
	"""
	return _hi.hi_Debug()

def Set_Debug(value):
	"""
	Set_Debug Sets Go Variable: hi.Debug
	
	"""
	if isinstance(value, go.GoClass):
		_hi.hi_Set_Debug(value.handle)
	else:
		_hi.hi_Set_Debug(value)

def IntArray():
	"""
	IntArray Gets Go Variable: hi.IntArray
	
	"""
	return Array_2_int(handle=_hi.hi_IntArray())

def IntSlice():
	"""
	IntSlice Gets Go Variable: hi.IntSlice
	
	"""
	return go.Slice_int(handle=_hi.hi_IntSlice())

def Set_IntSlice(value):
	"""
	Set_IntSlice Sets Go Variable: hi.IntSlice
	
	"""
	if isinstance(value, go.GoClass):
		_hi.hi_Set_IntSlice(value.handle)
	else:
		_hi.hi_Set_IntSlice(value)



# ---- Interfaces ---

# Python type for interface hi.PersIface
class PersIface(go.GoClass):
	"""PersIface is an interface into the person type.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
		else:
			self.handle = 0
	def GetAge(self):
		"""GetAge() int"""
		return _hi.hi_PersIface_GetAge(self.handle)
	def GetName(self):
		"""GetName() str"""
		return _hi.hi_PersIface_GetName(self.handle)
	def Greet(self):
		"""Greet() str"""
		return _hi.hi_PersIface_Greet(self.handle)
	def SetAge(self, age, goRun=False):
		"""SetAge(int age) """
		_hi.hi_PersIface_SetAge(self.handle, age, goRun)
	def SetName(self, n, goRun=False):
		"""SetName(str n) """
		_hi.hi_PersIface_SetName(self.handle, n, goRun)


# ---- Structs ---

# Python type for struct hi.Couple
class Couple(go.GoClass):
	"""Couple is a pair of persons\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
		else:
			self.handle = _hi.hi_Couple_CTor()
			if  0 < len(args):
				self.P1 = args[0]
			if "P1" in kwargs:
				self.P1 = kwargs["P1"]
			if  1 < len(args):
				self.P2 = args[1]
			if "P2" in kwargs:
				self.P2 = kwargs["P2"]
	def __str__(self):
		return self.String()
	
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'hi.Couple ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def P1(self):
		return Person(handle=_hi.hi_Couple_P1_Get(self.handle))
	@P1.setter
	def P1(self, value):
		if isinstance(value, go.GoClass):
			_hi.hi_Couple_P1_Set(self.handle, value.handle)
		else:
			_hi.hi_Couple_P1_Set(self.handle, value)
	@property
	def P2(self):
		return Person(handle=_hi.hi_Couple_P2_Get(self.handle))
	@P2.setter
	def P2(self, value):
		if isinstance(value, go.GoClass):
			_hi.hi_Couple_P2_Set(self.handle, value.handle)
		else:
			_hi.hi_Couple_P2_Set(self.handle, value)
	def String(self):
		"""String() str"""
		return _hi.hi_Couple_String(self.handle)

# Python type for struct hi.Person
class Person(go.GoClass):
	"""Person is a simple struct\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
		else:
			self.handle = _hi.hi_Person_CTor()
			if  0 < len(args):
				self.Name = args[0]
			if "Name" in kwargs:
				self.Name = kwargs["Name"]
			if  1 < len(args):
				self.Age = args[1]
			if "Age" in kwargs:
				self.Age = kwargs["Age"]
	def __str__(self):
		return self.String()
	
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'hi.Person ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Name(self):
		return _hi.hi_Person_Name_Get(self.handle)
	@Name.setter
	def Name(self, value):
		if isinstance(value, go.GoClass):
			_hi.hi_Person_Name_Set(self.handle, value.handle)
		else:
			_hi.hi_Person_Name_Set(self.handle, value)
	@property
	def Age(self):
		return _hi.hi_Person_Age_Get(self.handle)
	@Age.setter
	def Age(self, value):
		if isinstance(value, go.GoClass):
			_hi.hi_Person_Age_Set(self.handle, value.handle)
		else:
			_hi.hi_Person_Age_Set(self.handle, value)
	def String(self):
		"""String() str"""
		return _hi.hi_Person_String(self.handle)
	def Greet(self):
		"""Greet() str
		
		Greet sends greetings
		"""
		return _hi.hi_Person_Greet(self.handle)
	def Work(self, h):
		"""Work(int h) str
		
		Work makes a Person go to work for h hours
		"""
		return _hi.hi_Person_Work(self.handle, h)
	def Salary(self, h):
		"""Salary(int h) int, str
		
		Salary returns the expected gains after h hours of work
		"""
		return _hi.hi_Person_Salary(self.handle, h)
	def GetName(self):
		"""GetName() str"""
		return _hi.hi_Person_GetName(self.handle)
	def GetAge(self):
		"""GetAge() int"""
		return _hi.hi_Person_GetAge(self.handle)
	def SetName(self, n, goRun=False):
		"""SetName(str n) """
		_hi.hi_Person_SetName(self.handle, n, goRun)
	def SetAge(self, age, goRun=False):
		"""SetAge(int age) """
		_hi.hi_Person_SetAge(self.handle, age, goRun)
	def SetFmS2(self, s2, goRun=False):
		"""SetFmS2(object s2) """
		_hi.hi_Person_SetFmS2(self.handle, s2.handle, goRun)
	def SetFmS2Ptr(self, s2, goRun=False):
		"""SetFmS2Ptr(object s2) """
		_hi.hi_Person_SetFmS2Ptr(self.handle, s2.handle, goRun)
	def ReturnS2Ptr(self):
		"""ReturnS2Ptr() object"""
		return go.Ptr_structs_S2(handle=_hi.hi_Person_ReturnS2Ptr(self.handle))


# ---- Slices ---

# Python type for slice hi.Floats
class Floats(go.GoClass):
	"""Floats is a slice of floats\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
		else:
			self.handle = _hi.hi_Floats_CTor()
			if len(args) > 0:
				if not isinstance(args[0], collections.Iterable):
					raise TypeError('hi_Floats.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __str__(self):
		s = 'hi.hi_Floats len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'hi.hi_Floats([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _hi.hi_Floats_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return _hi.hi_Floats_elem(self.handle, key)
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_hi.hi_Floats_set(self.handle, idx, value)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, collections.Iterable):
			raise TypeError('hi_Floats.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = _hi.hi_Floats_elem(self.handle, self.index)
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_hi.hi_Floats_append(self.handle, value)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]


# ---- Maps ---


# ---- Constructors ---
def NewCouple(p1, p2):
	"""NewCouple(object p1, object p2) object
	
	NewCouple returns a new couple made of the p1 and p2 persons.
	"""
	return Couple(handle=_hi.hi_NewCouple(p1.handle, p2.handle))
def NewPerson(name, age):
	"""NewPerson(str name, int age) object
	
	NewPerson creates a new Person value
	"""
	return Person(handle=_hi.hi_NewPerson(name, age))
def NewPersonWithAge(age):
	"""NewPersonWithAge(int age) object
	
	NewPersonWithAge creates a new Person with a specific age
	"""
	return Person(handle=_hi.hi_NewPersonWithAge(age))
def NewActivePerson(h):
	"""NewActivePerson(int h) object, str
	
	NewActivePerson creates a new Person with a certain amount of work done.
	"""
	return Person(handle=_hi.hi_NewActivePerson(h))


# ---- Functions ---
def Concat(s1, s2):
	"""Concat(str s1, str s2) str
	
	Concat concatenates two strings together and returns the resulting string.
	"""
	return _hi.hi_Concat(s1, s2)
def Hi(goRun=False):
	"""Hi() 
	
	Hi prints hi from Go
	"""
	_hi.hi_Hi(goRun)
def Add(i, j):
	"""Add(int i, int j) int
	
	Add returns the sum of its arguments.
	"""
	return _hi.hi_Add(i, j)
def Hello(s, goRun=False):
	"""Hello(str s) 
	
	Hello prints a greeting from Go
	"""
	_hi.hi_Hello(s, goRun)
def LookupQuestion(n):
	"""LookupQuestion(int n) str, str
	
	LookupQuestion returns question for given answer.
	"""
	return _hi.hi_LookupQuestion(n)
def PersonAsIface(name, age):
	"""PersonAsIface(str name, int age) object"""
	return PersIface(handle=_hi.hi_PersonAsIface(name, age))


